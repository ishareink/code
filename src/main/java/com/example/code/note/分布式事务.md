### [分布式事务](https://juejin.cn/post/6944882663148748807#heading-12)

什么是分布式事务？比如在分布式中有库存服务对应库存数据库，订单服务对应订单数据库，做到保证他们的事务，就是分布式事务

#### 前置知识

* ACID

A原子性：所有操作要么全部成功，要么全部失败，undolog

C 一致性： 执行前和执行之后保证数据一致性

I 隔离型：保证不同事务发生时修改的隔离

D 持久性： 一旦提交，永久保存 两阶段提交

* **CAP**

**C（Consistency）**：一致性。服务A、B、C三个节点都存储了用户数据，三个节点的数据都需要保持同一时刻数据一致性，对于客户端来说，读操作能够返回最新的写操作，每个节点都是这样，就是强一致性

**A（Availability）**：可用性。服务A、B、C三个节点，其中一个节点如果宕机了，不能影响整个集群对外提供服务。

**P（Partition Tolerance）**：分区容错性就是允许系统通过网络协同工作，在出现网络分区后，出现网络故障，但是集群仍然可以提供正常工作

> 大多数是AP理论

* **BASE**

BA基本可用：当出现故障的时候，允许出现部分不可用，但是核心必须可用

S软状态 ：允许系统出现中间状态，就是不一致的读取

E最终一致性：但是经过一段时间保证数据最终完全一致

#### 全局事务/两阶段提交(2PC)

第一阶段：事务管理器通知参与事务的服务先进行自己的预提交操作，所有参与者都将自己的事务进行预提交，并将能否成功的信息反馈给事务管理器

第二阶段：事务管理器发现可以一起提交，通知准备就绪 ，让服务各自去各自的资源管理器真正修改资源，统一提交或者回滚

优点： 尽量保证了数据的强一致，实现成本较低，对于MySQL是从5.5开始支持。

缺点：1、单点问题：第一阶段之后，事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。

2、同步阻塞：如果没到第二阶段，资源管理器只能一直同步阻塞，提交才能释放资源，延迟了提交事件，加长了资源阻塞事件，不适合高并发的场景

3、数据不一致：如果执行到第二阶段，有可能分布式系统长期运行导致网络问题，部分参与者接收到 **commit** 消息，部分没有收到，那也只有部分参与者提交了事务，依然会导致数据不一致问题

#### 三阶段提交

第一阶段：准备阶段：询问是否可以提交 但是不锁死资源

第二阶段：预提交阶段 事务管理器向各个参加者发送准备提交请求，各个参与者接到请求后，将处理结果记录到自己的资源管理器中，如果准备好了，就会想协调者反馈`ACK`表示我已经准备好提交了

第三阶段：提交阶段 事务管理器向各个参与者发送提交请求 各个服务将自己的事务操作执行提交操作，执行完后，反馈ack给协调者 如果存在参与者的没有预提交这个状态或者反馈ack超时，他就会中断事务

相比两阶段提交本质上其实是增加了一个超时 稍微避免了单点问题

#### TCC事务

补偿性分布式事务 **针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作**

- **Try**：尝试待执行的业务
- **Confirm**：确认执行业务
- **Cancel**：取消待执行的业务

**优点：把数据库层的二阶段提交上提到了应用层来实现，规避了数据库的 2PC 性能低下问题

**缺点**：TCC 的 Try、Confirm 和 Cancel 操作功能需业务提供，开发成本高。TCC 对业务的侵入较大和业务紧耦合，需要根据特定的场景和业务逻辑来设计相应的操作

#### 可靠消息事务

第一个步骤：A 服务向消息中间件发布消息-中间件存储这个消息回发应答，A服务执行事务完毕后，提交一个消息表示提交状态

如果消息中间件在最后的过程中，长时间没有收到服务A 发送的 **Commit** 或 **Rollback** 指令，这个时候就需要依靠 **超时询问机制**

**超时询问机制**：

服务A除了实现正常的业务流程之外，还是需要提供一个可供消息中间件事务询问的接口。在消息中间件第一次收到消息后便会开始计时，如果超过规定的时间没有收到后续的指令，就会主动调用服务A提供的事务询问接口，询问当前服务的状态，通常来说该接口会返回三种结果，中间件需要根据这三种不同的结果做出不同的处理：

- 提交：直接将该消息投递给服务B
- 回滚：直接将该消息丢弃
- 处理中：继续等待，重新计时

第二个步骤：中间件收到这个提交后，投递消息给B服务，B事务处理成功，回发一个消息给中间件

正常情况：消息中间件投递完消息后，进入阻塞等待状态，在收到确认应答后便认为事务处理完成，该流程结束

等待超时情况：在等待确认应答超时之后就会重新进行投递，直到B服务器返回消费成功响应为止。而消息重试的次数和时间间隔都可以设置，如果最终还是不能成功进行投递，则需要人工干预。

#### 最大努力通知

最大努力通知也成为定期校对，是对可靠消息服务的进一步优化。它引入了本地消息表来记录错误消息，然后加入失败消息的定期校对功能，来进一步保证消息会被下游服务消费。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c774448b3f1548b2952ed29de2f5d00b~tplv-k3u1fbpfcp-watermark.image)

**步骤一：**服务A向消息中间件发送消息

1. 在处理业务的同一个事务中，向本地消息表写入一条记录
2. 消息发送者不断取出本地消息表中的消息发送到消息中间件，如果发送失败则进行重试

**步骤二：**消息中间件向服务B投递消息

1. 消息中间件收到消息后便会将消息投递到下游服务B，服务B收到消息后便会执行自己的业务
2. 当服务B业务处理成功后，便会向消息中间件返回反馈应答，消息中间件便可将该消息删除，该流程结束
3. 如果消息中间件向服务B投递消息失败，便会尝试重试，如果重试失败，便会将该消息接入失败消息表中
4. 消息中间件同样需要提供查询失败消息的接口，服务B 定期查询失败信息，并进行消费

最大努力通知的方案实现比较简单，适用于一些最终一致性要求比较低的业务。

### Seata

**Seata**的设计目标是对业务无侵入，因此它是从业务无侵入的两阶段提交（全局事务）着手，在传统的两阶段上进行改进，他把一个分布式事务理解成一个包含了若干分支事务的全局事务。而全局事务的职责是协调它管理的分支事务达成一致性，要么一起成功提交，要么一起失败回滚。也就是一荣俱荣一损俱损~

角色：

**TC（Transaction Coordinator）**：事务协调者。管理全局的分支事务的状态，用于全局性事务的提交和回滚。

**TM（Transaction Manager）**：事务管理者。用于开启、提交或回滚事务。

**RM（Resource Manager）**：资源管理器。用于分支事务上的资源管理，向 **TC**注册分支事务，上报分支事务的状态，接收 **TC**的命令来提交或者回滚分支事务



![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8772d28e1f134835b9f36bbc493c8107~tplv-k3u1fbpfcp-watermark.image)







